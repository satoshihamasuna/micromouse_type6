/*
 * make_path.cpp
 *
 *  Created on: 2023/06/26
 *      Author: sato1
 */

#include "typedef.h"
#include "macro.h"
#include "make_path.h"
#include "run_task.h"

#define DIJKSTRA_MAX_TIME (UINT16_MAX-1)

t_posDijkstra Dijkstra::SetNodePos(uint8_t _x,uint8_t _y,t_DijkstraNodePos _dpos)
{
	t_posDijkstra pos;
	pos.x = _x;
	pos.y = _y;
	pos.NodePos = _dpos;
	return pos;
}

t_element Dijkstra::SetNode(t_DijkstraNodePos _parent,	uint16_t _time,		t_direction _dir
				 ,t_run_pattern _run_pt,		t_bool _determine)
{
	t_element node;
	node.parent_pos = _parent;
	node.time		= _time;
	node.dir		= _dir;
	node.run_pt		= _run_pt;
	node.determine  = _determine;
	return node;
}

void Dijkstra::init_dijkstra_map(t_position start_pos)
{
	for(int i = 0;i < MAZE_SIZE_X;i++)
	{
		for(int j = 0;j < MAZE_SIZE_Y;j++)
		{
			for(int d = 0; d < 3;d++)
			{
				switch(d)
				{
					case C_pos:

						break;
					case N_pos:
						if(wall_property->wall[i][j].north == NOWALL)
						{
							closure[i][j].North = SetNode, MAP_MAX_VALUE, , No_run, (_wall_property->wall[i][j].north == NOWALL)?False:True)
						}
						else
						{

						}
						break;

					case E_pos:
						if(wall_property->wall[i][j].north == NOWALL)
						{

						}
						else
						{

						}
						break;
				}
			}
		}
	}
}

void Dijkstra::start_node_setUp(t_position start_pos)
{

}

t_bool Dijkstra::is_goal_Dijkstra(t_position goal_pos,uint8_t goal_size)
{

}

t_posDijkstra Dijkstra::min_search()
{
	t_posDijkstra min_pos;

	return min_pos;
}



t_posDijkstra Dijkstra::make_path_Dijkstra(t_position start_pos,t_position goal_pos,uint8_t goal_size)
{

}

void Dijkstra::run_Dijkstra(t_position start_pos,t_position goal_pos,uint8_t goal_size)
{

}
